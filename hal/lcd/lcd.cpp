/*
 * lcd.cpp
 *
 *  Created on: Aug 28, 2018
 *      Author: zhanlei
 */

#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

#include <sys/ioctl.h>
#include <linux/i2c.h>
#include <linux/i2c-dev.h>

#include "../gpio/gpio.h"
#include "lcd.h"

#define LCD_WIDTH			256u
#define LCD_HIGH			128u
#define LCD_BIT_PER_PIXEL	1u

struct command {
	uint8_t *code;
	size_t len;
};

//=============================Generated By Tools==============================
// EXT=0
static uint8_t _cmd_0[] = {0x80u, 0x30u};
// Sleep out
static uint8_t _cmd_1[] = {0x80u, 0x94u};
// EXT=1
static uint8_t _cmd_2[] = {0x80u, 0x31u};
// Autoread disable
static uint8_t _cmd_3[] = {0x80u, 0xD7u, 0x40u, 0x9Fu};
// Analog SET, OSC Frequency adjustment, Frequency on booster capacitors->6KHz, Bias=1/11
static uint8_t _cmd_4[] = {0x80u, 0x32u, 0x40u, 0x00u, 0x01u, 0x03u};
// Gray Level
static uint8_t _cmd_5[] = {0x80u, 0x20u, 0x40u, 0x01u, 0x03u, 0x05u, 0x07u, 0x09u, 0x0Bu, 0x0Du, 0x10u, 0x11u, 0x13u, 0x15u, 0x17u, 0x19u, 0x1Bu, 0x1Du, 0x1Fu};
// EXT=0
static uint8_t _cmd_6[] = {0x80u, 0x30u};
// Page Address setting, YS=32, YE=160 0x10
static uint8_t _cmd_7[] = {0x80u, 0x75u, 0x40u, 0x04u, 0x14u};
// Clumn Address setting, XS=0, XE=256
static uint8_t _cmd_8[] = {0x80u, 0x15u, 0x40u, 0x00u, 0xFFu};
// Data scan direction, MX.MY=Normal
static uint8_t _cmd_9[] = {0x80u, 0xBCu, 0x40u, 0x00u, 0x00u};
// Display Control, Duty=160, Nline=off
static uint8_t _cmd_10[] = {0x80u, 0xCAu, 0x40u, 0x00u, 0x9Fu, 0x20u};
// Display Mode, 10=Monochrome Mode,11=4Gray
static uint8_t _cmd_11[] = {0x80u, 0xF0u, 0x40u, 0x10u};
// EV control, VPR[5-0], VPR[8-6]
static uint8_t _cmd_12[] = {0x80u, 0x81u, 0x40u, 0x38u, 0x04u};
// Power control, D0=regulator ; D1=follower ; D3=booste,  on:1 off:0
static uint8_t _cmd_13[] = {0x80u, 0x20u, 0x40u, 0x0Bu};
// Display on
static uint8_t _cmd_14[] = {0x80u, 0xAFu};
static const struct command init_command_seq[] = {
	{_cmd_0, sizeof(_cmd_0)},
	{_cmd_1, sizeof(_cmd_1)},
	{_cmd_2, sizeof(_cmd_2)},
	{_cmd_3, sizeof(_cmd_3)},
	{_cmd_4, sizeof(_cmd_4)},
	{_cmd_5, sizeof(_cmd_5)},
	{_cmd_6, sizeof(_cmd_6)},
	{_cmd_7, sizeof(_cmd_7)},
	{_cmd_8, sizeof(_cmd_8)},
	{_cmd_9, sizeof(_cmd_9)},
	{_cmd_10, sizeof(_cmd_10)},
	{_cmd_11, sizeof(_cmd_11)},
	{_cmd_12, sizeof(_cmd_12)},
	{_cmd_13, sizeof(_cmd_13)},
	{_cmd_14, sizeof(_cmd_14)},
};
static const size_t init_command_num = sizeof(init_command_seq) / sizeof(struct command);
//************************************End**************************************

static const uint8_t bit_code[] = {
	0b00000001,
	0b00000011,
	0b00000111,
	0b00001111,
	0b00011111,
	0b00111111,
	0b01111111,
	0b11111111,
};

inline void Lcd::write_buf_byte(int index, Color color, uint8_t d)
{
	switch (color) {
	case E_BLUE:
		m_frame_buffer[index] &= ~d;
		break;
	case E_WHITE:
		m_frame_buffer[index] |= d;
		break;
	default:
		break;
	}
}

Lcd::Lcd(uint32_t i2c, uint8_t addr, uint32_t reset_pin, uint32_t bkl_pin)
{
	char buf[10];
	m_reset_pin = new Gpio(reset_pin);
	if (m_reset_pin == NULL) {
		printf("new memory for reset pin failed\n");
		exit(-1);
	}

	m_reset_pin->set_direction(Gpio::E_OUT);
	m_reset_pin->reset(true);
	// delay 600ms
	usleep(600000);
	m_reset_pin->set(true);

	m_i2c_addr = addr;

	snprintf(buf, sizeof(buf), "%u", i2c);
	m_i2c_dev_path = "/dev/i2c-";
	m_i2c_dev_path += buf;
	m_i2c_fd = open(m_i2c_dev_path.c_str(), O_RDWR);
	if (m_i2c_fd < 0) {
		printf("open %s failed\n", m_i2c_dev_path.c_str());
		exit(-1);
	}

	m_frame_buffer_size = LCD_WIDTH * LCD_HIGH / 8;
	m_frame_mem_ptr = new uint8_t[m_frame_buffer_size + 3];
	if (m_frame_mem_ptr == NULL) {
		printf("new memory for lcd frame buffer failed\n");
		exit(-1);
	}
	m_frame_mem_ptr[0] = 0x80u;
	m_frame_mem_ptr[1] = 0x5cu;
	m_frame_mem_ptr[2] = 0x40u;
	m_frame_buffer = &m_frame_mem_ptr[3];
	memset(m_frame_buffer, 0, m_frame_buffer_size);

	m_backlight_pin = new Gpio(bkl_pin);
	if (m_reset_pin == NULL) {
		printf("new memory for backlight pin failed\n");
		exit(-1);
	}
	m_backlight_pin->set_direction(Gpio::E_OUT);
	m_backlight_pin->set(true);
}

Lcd::~Lcd()
{
	if (m_i2c_fd >= 0) {
		close(m_i2c_fd);
	}

	if (m_reset_pin) {
		m_reset_pin->reset(true);
		delete m_reset_pin;
	}

	if (m_backlight_pin) {
		m_backlight_pin->reset(true);
		delete m_backlight_pin;
	}

	if (m_frame_mem_ptr) {
		delete m_frame_mem_ptr;
	}
}

Lcd &Lcd::instance()
{
	static Lcd lcd(1, 0x3f, 24, 25);
	return lcd;
}

bool Lcd::init()
{
	bool ret_val(false);
	printf("init_command_num = %d\n", init_command_num);
	for (size_t i = 0; i < init_command_num; i++) {
		ret_val = send_data(init_command_seq[i].code, init_command_seq[i].len);
		if (!ret_val) {
			printf("init failed at step %u\n", i);
		}
		usleep(10000);
	}
	return ret_val;
}

bool Lcd::sync()
{
	bool ret_val(false);
	ret_val = send_data(_cmd_7, sizeof(_cmd_7));
	if (ret_val) {
		ret_val = send_data(_cmd_8, sizeof(_cmd_8));
		if (ret_val) {
			ret_val = send_data(m_frame_mem_ptr, m_frame_buffer_size + 3);
		} else {
			printf("set position of x failed\n");
		}
	} else {
		printf("set position of y failed\n");
	}
	return ret_val;
}

void Lcd::clear()
{
	memset(m_frame_buffer, 0, m_frame_buffer_size);
}

void Lcd::draw_point(int x, int y, Color color)
{
	// out range
	if ((x < 0) || (x >= (int)LCD_WIDTH)) {
		return;
	}

	if ((y < 0) || (y >= (int)LCD_HIGH)) {
		return;
	}

	int _y0 = 7 - y % 8, _y1 = y / 8;
	uint32_t index = _y1 * LCD_WIDTH + x;
	uint8_t _d = 0x01 << _y0;
	write_buf_byte(index, color, _d);
}

void Lcd::draw_v_line(int x, int y0, int y1, Color color)
{
	// out range
	if ((x < 0) || (x >= (int)LCD_WIDTH)) {
		return;
	}

	if (y0 < 0) {
		y0 = 0;
	} else if (y0 > (int)LCD_HIGH) {
		y0 = LCD_HIGH;
	}

	if (y1 < 0) {
		y1 = 0;
	} else if (y1 > (int)LCD_HIGH) {
		y1 = LCD_HIGH;
	}

	if (y1 < y0) {
		int t = y0;
		y0 = y1;
		y1 = t;
	}

	if (y1 == y0) {
		return;
	}

	int y0_byte = y0 / 8, y0_bit = 7 - y0 % 8;
	int y1_byte = y1 / 8, y1_bit = 7 - y1 % 8;
	int index = x + y0_byte * (int)LCD_WIDTH;
	uint8_t _d = bit_code[y0_bit];
	if (y1_byte > y0_byte) {
		write_buf_byte(index, color, _d);
		_d = 0xffu;
		for (int i = y0_byte + 1; i < y1_byte; i++) {
			index = x + i * LCD_WIDTH;
			write_buf_byte(index, color, _d);
		}
		_d = ~bit_code[y1_bit];
		index = x + y1_byte * (int)LCD_WIDTH;
		write_buf_byte(index, color, _d);
	} else {
		_d &= ~bit_code[y1_bit];
		write_buf_byte(index, color, _d);
	}
}

void Lcd::draw_h_line(int x0, int x1, int y, Color color)
{
	// out range
	if ((y < 0) || (y >= (int)LCD_HIGH)) {
		return;
	}

	if (x0 < 0) {
		x0 = 0;
	} else if (x0 > (int)LCD_WIDTH) {
		x0 = LCD_WIDTH;
	}

	if (x1 < 0) {
		x1 = 0;
	} else if (x1 > (int)LCD_WIDTH) {
		x1 = LCD_WIDTH;
	}

	if (x1 < x0) {
		int t = x0;
		x0 = x1;
		x1 = t;
	}

	if (x1 == x0) {
		return;
	}

	uint8_t _d = 0x01 << (7 - y % 8);
	int index;
	for (int i = x0; i < x1; i++) {
		index = i + y / 8 * LCD_WIDTH;
		write_buf_byte(index, color, _d);
	}
}

void Lcd::draw_line(int x0, int y0, int x1, int y1, Color color)
{
	if (x0 < 0) {
		x0 = 0;
	} else if (x0 > (int)LCD_WIDTH) {
		x0 = LCD_WIDTH;
	}

	if (x1 < 0) {
		x1 = 0;
	} else if (x1 > (int)LCD_WIDTH) {
		x1 = LCD_WIDTH;
	}

	if (y0 < 0) {
		y0 = 0;
	} else if (y0 > (int)LCD_HIGH) {
		y0 = LCD_HIGH;
	}

	if (y1 < 0) {
		y1 = 0;
	} else if (y1 > (int)LCD_HIGH) {
		y1 = LCD_HIGH;
	}

	if (x1 == x0) {
		draw_v_line(x0, y0, y1, color);
		return;
	}

	if (y1 == y0) {
		draw_h_line(x0, x1, y0, color);
		return;
	}

	int dx, sx;
	int dy, sy;
	int err, this_err;

	if (x0 < x1) {
		dx = x1 - x0;
		sx = 1;
	} else {
		dx = x0 - x1;
		sx = -1;
	}

	if (y0 < y1) {
		dy = y1 - y0;
		sy = 1;
	} else {
		dy = y0 - y1;
		sy = -1;
	}
	err = (dx > dy? dx : -dy) / 2;

	for (;;) {
		if (x0 == x1 && y0 == y1)
			break;
		draw_point(x0, y0, Lcd::E_WHITE);
		this_err = err;
		if (this_err > -dx) {
			err -= dy;
			x0 += sx;
		}

		if (this_err < dy) {
			err += dx;
			y0 += sy;
		}
	}
}

void Lcd::draw_bitmap_1(int x0, int y0, int w, int h, const char *data, bool inverse)
{

}

void Lcd::fill_rect(int x0, int y0, int x1, int y1, Color color)
{

}

void Lcd::flush_ram(int column, int row, size_t total_column, size_t total_row)
{

}

void Lcd::set_ram(int column, int row, size_t total_column, const uint8_t *src, size_t size)
{
	for (int i = 0; i < (int)size; i++) {
		int _d_column = i % total_column;
		int _column = column + _d_column;
		if ((_column >= 0) && (_column < (int)LCD_WIDTH)) {
			int _index = _column + row * LCD_WIDTH;
			if ((_index >= 0) && (_index < (int)m_frame_buffer_size)) {
				m_frame_buffer[_index] = src[i];
			}
		}
		if (_d_column + 1 == (int)total_column) {
			row++;
		}
	}
}

bool Lcd::send_data(void *data, size_t len)
{
	bool ret_val(false);
	struct i2c_rdwr_ioctl_data work_queue;
	struct i2c_msg msg;

	work_queue.nmsgs = 1;
	work_queue.msgs = &msg;

	msg.addr = m_i2c_addr;
	// write = 0
	// read = 1
	msg.flags = 0;
	msg.len = (__u16)len;
	msg.buf = (__u8 *)data;
	int ret = ioctl(m_i2c_fd, I2C_RDWR, &work_queue);
	if (ret < 0) {
		printf("send data(size %u) by i2c(%s@0x%02X) failed\n", (uint32_t)len, m_i2c_dev_path.c_str(), m_i2c_addr);
	} else {
		ret_val = true;
	}
	return ret_val;
}
