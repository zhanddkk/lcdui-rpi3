/*
 * lcd.cpp
 *
 *  Created on: Aug 28, 2018
 *      Author: zhanlei
 */

#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

#include <sys/ioctl.h>
#include <linux/i2c.h>
#include <linux/i2c-dev.h>

#include "../gpio/gpio.h"
#include "lcd.h"
//#include "logo.h"

#define LCD_WIDTH			256u
#define LCD_HIGH			128u
#define LCD_BIT_PER_PIXEL	1u

struct command {
	uint8_t *code;
	size_t len;
};

//=============================Generated By Tools==============================
// EXT=0
static uint8_t _cmd_0[] = {0x80u, 0x30u};
// Sleep out
static uint8_t _cmd_1[] = {0x80u, 0x94u};
// EXT=1
static uint8_t _cmd_2[] = {0x80u, 0x31u};
// Autoread disable
static uint8_t _cmd_3[] = {0x80u, 0xD7u, 0x40u, 0x9Fu};
// Analog SET, OSC Frequency adjustment, Frequency on booster capacitors->6KHz, Bias=1/11
static uint8_t _cmd_4[] = {0x80u, 0x32u, 0x40u, 0x00u, 0x01u, 0x03u};
// Gray Level
static uint8_t _cmd_5[] = {0x80u, 0x20u, 0x40u, 0x01u, 0x03u, 0x05u, 0x07u, 0x09u, 0x0Bu, 0x0Du, 0x10u, 0x11u, 0x13u, 0x15u, 0x17u, 0x19u, 0x1Bu, 0x1Du, 0x1Fu};
// EXT=0
static uint8_t _cmd_6[] = {0x80u, 0x30u};
// Page Address setting, YS=32, YE=160 0x10
static uint8_t _cmd_7[] = {0x80u, 0x75u, 0x40u, 0x04u, 0x14u};
// Clumn Address setting, XS=0, XE=256
static uint8_t _cmd_8[] = {0x80u, 0x15u, 0x40u, 0x00u, 0xFFu};
// Data scan direction, MX.MY=Normal
static uint8_t _cmd_9[] = {0x80u, 0xBCu, 0x40u, 0x00u, 0x00u};
// Display Control, Duty=160, Nline=off
static uint8_t _cmd_10[] = {0x80u, 0xCAu, 0x40u, 0x00u, 0x9Fu, 0x20u};
// Display Mode, 10=Monochrome Mode,11=4Gray
static uint8_t _cmd_11[] = {0x80u, 0xF0u, 0x40u, 0x10u};
// EV control, VPR[5-0], VPR[8-6]
static uint8_t _cmd_12[] = {0x80u, 0x81u, 0x40u, 0x38u, 0x04u};
// Power control, D0=regulator ; D1=follower ; D3=booste,  on:1 off:0
static uint8_t _cmd_13[] = {0x80u, 0x20u, 0x40u, 0x0Bu};
// Display on
static uint8_t _cmd_14[] = {0x80u, 0xAFu};
static const struct command init_command_seq[] = {
	{_cmd_0, sizeof(_cmd_0)},
	{_cmd_1, sizeof(_cmd_1)},
	{_cmd_2, sizeof(_cmd_2)},
	{_cmd_3, sizeof(_cmd_3)},
	{_cmd_4, sizeof(_cmd_4)},
	{_cmd_5, sizeof(_cmd_5)},
	{_cmd_6, sizeof(_cmd_6)},
	{_cmd_7, sizeof(_cmd_7)},
	{_cmd_8, sizeof(_cmd_8)},
	{_cmd_9, sizeof(_cmd_9)},
	{_cmd_10, sizeof(_cmd_10)},
	{_cmd_11, sizeof(_cmd_11)},
	{_cmd_12, sizeof(_cmd_12)},
	{_cmd_13, sizeof(_cmd_13)},
	{_cmd_14, sizeof(_cmd_14)},
};
static const size_t init_command_num = sizeof(init_command_seq) / sizeof(struct command);
//************************************End**************************************

Lcd::Lcd(uint32_t i2c, uint8_t addr, uint32_t reset_pin, uint32_t bkl_pin)
{
	char buf[10];
	m_reset_pin = new Gpio(reset_pin);
	if (m_reset_pin == NULL) {
		printf("new memory for reset pin failed\n");
		exit(-1);
	}

	m_reset_pin->set_direction(Gpio::E_OUT);
	m_reset_pin->reset(true);
	// delay 60ms
	usleep(60000);
	m_reset_pin->set(true);

	m_i2c_addr = addr;

	snprintf(buf, sizeof(buf), "%u", i2c);
	m_i2c_dev_path = "/dev/i2c-";
	m_i2c_dev_path += buf;
	m_i2c_fd = open(m_i2c_dev_path.c_str(), O_RDWR);
	if (m_i2c_fd < 0) {
		printf("open %s failed\n", m_i2c_dev_path.c_str());
		exit(-1);
	}

	m_frame_buffer_size = LCD_WIDTH * LCD_HIGH / 8;
	m_frame_mem_ptr = new uint8_t[m_frame_buffer_size + 3];
	if (m_frame_mem_ptr == NULL) {
		printf("new memory for lcd frame buffer failed\n");
		exit(-1);
	}
	m_frame_mem_ptr[0] = 0x80u;
	m_frame_mem_ptr[1] = 0x5cu;
	m_frame_mem_ptr[2] = 0x40u;
	m_frame_buffer = &m_frame_mem_ptr[3];
	memset(m_frame_buffer, 0xaau, m_frame_buffer_size);
	m_frame_buffer[0] = 0x05;

	m_backlight_pin = new Gpio(bkl_pin);
	if (m_reset_pin == NULL) {
		printf("new memory for backlight pin failed\n");
		exit(-1);
	}
	m_backlight_pin->set_direction(Gpio::E_OUT);
	m_backlight_pin->set(true);
}

Lcd::~Lcd()
{
	if (m_i2c_fd >= 0) {
		close(m_i2c_fd);
	}

	if (m_reset_pin) {
		delete m_reset_pin;
	}

	if (m_frame_mem_ptr) {
		delete m_frame_mem_ptr;
	}
	m_reset_pin->reset(true);
}

bool Lcd::init()
{
	bool ret_val(false);
	printf("init_command_num = %d\n", init_command_num);
	for (size_t i = 0; i < init_command_num; i++) {
		ret_val = send_data(init_command_seq[i].code, init_command_seq[i].len);
		if (!ret_val) {
			printf("init failed at step %u\n", i);
		}
	}
	return ret_val;
}

bool Lcd::sync()
{
	bool ret_val(false);
	ret_val = send_data(_cmd_7, sizeof(_cmd_7));
	if (ret_val) {
		ret_val = send_data(_cmd_8, sizeof(_cmd_8));
		if (ret_val) {
			ret_val = send_data(m_frame_mem_ptr, m_frame_buffer_size + 3);
		} else {
			printf("set position of x failed\n");
		}
	} else {
		printf("set position of y failed\n");
	}
	return ret_val;
}

bool Lcd::send_data(void *data, size_t len)
{
	bool ret_val(false);
	struct i2c_rdwr_ioctl_data work_queue;
	struct i2c_msg msg;

	work_queue.nmsgs = 1;
	work_queue.msgs = &msg;

	msg.addr = m_i2c_addr;
	// write = 0
	// read = 1
	msg.flags = 0;
	msg.len = (__u16)len;
	msg.buf = (__u8 *)data;
	int ret = ioctl(m_i2c_fd, I2C_RDWR, &work_queue);
	if (ret < 0) {
		printf("send data(size %u) by i2c(%s@0x%02X) failed\n", (uint32_t)len, m_i2c_dev_path.c_str(), m_i2c_addr);
	} else {
		ret_val = true;
	}
	return ret_val;
}
